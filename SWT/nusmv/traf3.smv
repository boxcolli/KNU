MODULE control_unit(input) -- Master Module

    DEFINE
        t_bef_ready := 2; -- time before ready
        t_bef_yellow := 9; -- time before yellow sign
        t_bef_left := 4; -- time before turn left sign
        t_bef_switch := 11; -- time before lane switch
        t_bef_pause := 2; -- time before completely pause
    
    VAR
        state : {
            Init, Ready, Pause,
            EW_0, EW_1, EW_2, -- green, left, yellow
            NS_0, NS_1, NS_2 };
        ew_go : { Red, Green, Yellow, Off, None };
        ew_left : { On, Off, None };
        ns_go : { Red, Green, Yellow, Off, None };
        ns_left : { On, Off, None };
        time : 0..12;
    
    ASSIGN
        init(state) := Init;
        init(con) := None;
        init(ew_go) : None;
        init(ew_left) : None;
        init(ns_go) : None;
        init(ns_left) : None;
        init(time) := 0;

        next(time) := case
            state = Ready & time <= t_bef_ready := time + 1;
            state = ( EW_0 | EW_1 | EW_2
                    | NS_0 | NS_1 | NS_2 )
                    & time <= t_bef_switch : time + 1;
            state = Pause & time <= t_bef_pause : time + 1;
            TRUE : 0;
        esac;
            
        next(state) := case
            -- ready
            state = Init & input = On : Ready;
            -- enter execution
            state = Ready & time = t_bef_ready : EW_0;
            -- lane east-west
            state = EW_0 & time = t_bef_left : EW_1;
            state = EW_1 & time = t_bef_yellow : EW_2;
            state = EW_2 & time = t_bef_switch : NS_0;
            -- lane north-south
            state = NS_0 & time = t_bef_left : NS_1;
            state = NS_1 & time = t_bef_yellow : NS_2;
            state = NS_2 & time = t_bef_switch : EW_0;
            -- pause
            state = ( EW_0 | EW_1 | EW_2
                    | NS_0 | NS_1 | NS_2 )
                    & input = Off : Pause;
            -- return to init
            state = Pause & time = t_bef_pause : Init;
            TRUE : state;
        
        next(ew_go) := case
            state = Init & input = On : Red;
            state = Ready & time = t_bef_ready : Green;
            state = EW_1 & time = t_bef_yellow : Yellow;
            state = EW_2 & time = t_bef_switch : Red;
            state = ( EW_0 | EW_1 | EW_2
                    | NS_0 | NS_1 | NS_2 )
                    & input = Off : Red;
            state = Pause & time = t_bef_pause : Off;
            TRUE : None;
        
        next(ew_left) := case
            state = EW_0 & time = t_bef_left : On;
            state = EW_1 & time = t_bef_yellow : Off;
            
            TRUE : None;

    FAIRNESS
        running

MODULE sign_board ( con_go, con_left ) -- Servant Module

    VAR
        go : { Red, Green, Yellow, Off };
        left : { On, Off };
    
    ASSIGN
        init(go) := Off;
        init(left) := Off;
    
        next(go) := case
            con_go = Red : Red;
            con_go = Green : Green;
            con_go = Yellow : Yellow;
            con_go = Off : Off;
            TRUE : go;
        esac;

        next(left) := case
            con_left = On : On;
            con_left = Off : Off;
            TRUE : left;
        esac;
    
    FAIRNESS
        running

MODULE main
    
    VAR
        input : { None, On, Off };
        cu : process control_unit(input);
        sb_ew : process sign_board(cu.ew_go, cu.ew_left);
        sb_ns : process sign_board(cu.ns_go, cu.ns_left);
    
    ASSIGN
        init(input) := None;

